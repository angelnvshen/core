package own.leetcode.map;

import own.jdk.ListNode;
import own.leetcode.TreeNode;

import java.util.*;

public class Demo {
    public static void main(String[] args) {
        Demo demo = new Demo();
//        System.out.println(demo.largestTimeFromDigits(new int[]{0, 0, 0, 0}));


        //hit"，end = "cog"，dict =["hot","dot","dog","lot","log"
//        System.out.println(demo.ladderLength("game", "cog", new HashSet<>(Arrays.asList("hot", "dot", "dog", "lot", "log"))));
//        System.out.println(demo.ladderLength("game", "thee", new HashSet<>(Arrays.asList("frye","heat","tree","thee","game","free","hell","fame","faye"))));
//        System.out.println(demo.ladderLength("kiss", "tusk", new HashSet<>(Arrays.asList("miss","dusk","kiss","musk","tusk","diss","disk","sang","ties","muss"))));


        /*Map<String, int[]> map = new HashMap<>();
        demo.toMap(map, "kiss");
        demo.toMap(map, "disk");
        demo.oneLetterChange(map, "kiss", "disk");*/

//        String[] strings = demo.reorderLogFiles(new String[]{"a1 9 2 3 1", "g1 act car", "zo4 4 7", "ab1 off key dog", "a8 act zoo"});
//        String[] strings = demo.reorderLogFiles(new String[]{"6p tzwmh ige mc", "ns 566543603829", "ubd cujg j d yf", "ha6 1 938 376 5", "3yx 97 666 56 5", "d 84 34353 2249", "0 tllgmf qp znc", "s 1088746413789", "ys0 splqqxoflgx", "uhb rfrwt qzx r", "u lrvmdt ykmox", "ah4 4209164350", "rap 7729 8 125", "4 nivgc qo z i", "apx 814023338 8"});
        /*String[] strings = demo.reorderLogFiles(new String[]{"wpylev6cnqv8 447241070789889321113517804297550370", "2syod 60098540876848105552318 69698830167476212 2", "iuw2x1r qmxealfvosqgkv yunonsq nxcuwudndrpsroty h", "vclnqwkdr7h 5515 892770977116949342793820104705 3", "5y08u4f5ba swixvlwipfhtxavvzrdyxtnronckklvh f kzd", "2k63p1p 542447297738584 22237063423417308275099706", "qrj 467859 382 451796621324556 12022 72631305 0429", "vopck4 huqziggmwvcsermnujnpplihttviwei lsrqmbw b n", "s 7257018672440110203152567646 961657508453405583", "94j 1800907 54116251858 19612167 218608 1 504204 4", "u34lvgmoh 631217074786612695089137448 5635620839 5", "dsrojn8aeojx 27159799084241651870 76594680 195 051", "kteuav 77685739 6366458436088787165747310 78 3849", "dg8gco0sc2 10811560194867165521681 718 42498 1 52", "gdg 900670532316533434070453812 9115641245822 122", "ytlmfg 658910166131 170942932 70238 0783568 64777", "gi6d2lg8 ekwbnzeqrrzijgexvpcgfnhrkfhtmegaqon hsa u", "y8zhzn jjtbwpfrbcsuj zmseejb vcsovstaewtgtj nbsnlj", "cp1qsk5 dstuzhik alqxnmztxnwdve simoynsfffwyacl nr", "a11zjdza15gi zuighjavkfidjjx kgmbriwxbjcsv shtfjz", "3dpx3f28wa1 dhe jb uatgwooxclfj w t qaahvyiy lthj", "9ymabvjk4xq waujeijoltuy heoekaqmggmpdkynngne sl x", "n3l09gzpppgc dfnfxeaskknllixe tvtbemewtkwd bfbhm l", "one 143245418564431590 555274555077126490673 23406", "2dlvtxq57 11 0399853766553806651446400571374174 7", "l0xsyrtf9foe jcsjyzbux hpxxwwsyxwjcdqbuzrxuvdf n n", "o ufjxgmiohhacgwhprzqklpbleggurqygvmyrqtiwwusaa fq", "gr jmhsaanfrndkvkrdepfqvnathkheq bjtvzacabyfch xw", "12hrfmpyxql 509513107446443470266800090 12 36792 5", "ei mfmrujazj hvcaeoejhbvsxlnbcofdparedjvuqoigbwv h", "158mo1 fxwvcxyaz gimthvk t tbkpxnyomitu i foi t i", "1mpnz91abn8 857526216042344 529 86 555850 074136 6", "gvf69aycgz vd wzshq vqqcoscdfgtclfpoqz kcnbk yqrta", "05tv1dyuuln 3010253552744498232332 86540056 5488 0", "1kjt2sp 76661129172454994454966100212569762 877775", "k8fq mhahouacluusiypbhmbxknagj nrenkpsijov tspqd s", "a 05783356043073570183098305205075240023467 24 63", "0c 821 1288302446431573478713998604686702 0584599", "e 02985850443721 356058 49996149758367 64432663 32", "1zayns7ifztd kwmwsthxzxvvctzoejspeobtavhzxzpot u n", "o0sh3 qn nqjaghnmkckhvuauuknqbuxwalgva nt gfhqm en", "094qnly wgkmupkjobuup gshx wcblufmjumyuahsx n ai k", "j69r2ugwa6 zuoywue chhwsfdprfygvliwzmohqgrxn ubwtm", "2mkuap uqfwog jqzrkoorsompgkdlql wpauhkzvig ftb l", "x 929 4356109428379557082235487428356570127401 832", "jns07q8 idnlfsaezcojuafbgmancqpegbzy q qwesz rmy n", "phk1cna 086 027760883273 64658492093523655560824 2", "jbemfs9l9bs0 8147538504741452659388775 5 32 180 09", "ac9cwb9 524689619771630155 8125241949139653850678", "9eke perwsfqykyslfmcwnovenuiy urstqeqaezuankek czq"});
        for (String s : strings) {
            System.out.println(s);
        }*/

        /*int[][] ints = {
                {0, 1, 0},
                {0, 0, 1},
                {1, 1, 1},
                {0, 0, 0},
        };
        demo.gameOfLife(ints);

        demo.print(ints);*/

        /*System.out.println(demo.firstMissingPositive(new int[]{3, 4, -1, 1}));
        System.out.println(demo.firstMissingPositive(new int[]{1,2,0}));
        System.out.println(demo.firstMissingPositive(new int[]{1,2,3}));
        System.out.println(demo.firstMissingPositive(new int[]{7,8,9,11,12}));*/

//        System.out.println(demo.longestConsecutive(new int[]{100, 4, 200, 1, 3, -12,}));

//        System.out.println(demo.combinationSum(new int[]{2, 3, 5}, 8));

//        System.out.println(demo.myPow(2.0, 5));
//        System.out.println(demo.countSmaller(new int[]{5, 2, 6, 13, 4, -1, 1, 0, 20}));

//        System.out.println(demo.divide(10, -3));
//        System.out.println(demo.divide(-2147483648, 1));

//        System.out.println(demo.mySqrt(2147395599));

//        System.out.println(demo.splitArray(new int[]{7, 2, 5, 10, 8}, 2));
//        System.out.println(demo.splitArray(new int[]{1, 2147483647}, 2));

//        for(int i = 0; i < 8; i ++)
//            System.out.println(demo.searchInsert(new int[]{1,3,5,6}, i) + " - " + i);

//        System.out.println(demo.lengthOfLIS_II(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));
//        System.out.println(demo.lengthOfLIS_II(new int[]{1, 3, 6, 7, 9, 4, 10, 5, 6}));


//        demo.maxSumSubmatrix(new int[][]{{1, 0, 1}, {0, -2, 3}}, 2);

//        System.out.println(demo.helper(new int[]{0, -2, 5, 4, 3}, 2));
//        System.out.println(demo.maxSumSubmatrix(new int[][]{{1, 0, 1, 3, 3, 12}, {10, 3, 4, 0, -2, 3}}, 2));

        /*System.out.println(demo.maxEnvelopes(new int[][]{
         *//*{5, 4},
                {6, 4},
                {6, 7},
                {2, 3},*//*

                {4, 5},
                {4, 6},
                {6, 7},
                {2, 3},
                {1, 1},
        }));*/

//        System.out.println((int)'a');
//        System.out.println((int)'z');
//        System.out.println((int)'A');
//        System.out.println((int)'Z');

//        System.out.println(demo.maximalRectangle(new char[][]{
//                {'1', '0', '1', '0', '0'},
//                {'1', '0', '1', '1', '1'},
//                {'1', '1', '1', '1', '1'},
//                {'1', '0', '0', '1', '0'},
//        }));

//        System.out.println(demo.isHappy(Integer.MAX_VALUE));

//        System.out.println(demo.topKFrequent(new int[]{1, 1, 1, 2, 2, 3}, 2));

//        System.out.println(demo.containsNearbyDuplicate(new int[]{1, 2, 3, 1}, 3));
//        System.out.println(demo.containsNearbyDuplicate(new int[]{1, 0, 1, 1}, 1));
//        System.out.println(demo.containsNearbyDuplicate(new int[]{1, 2, 3, 1, 2, 3}, 2));

//        System.out.println(demo.findWords(new String[]{"Hello", "Alaska", "Dad", "Peace"}));

        /*ListNode head = new ListNode(1);
        head.next(new ListNode(3)).next(new ListNode(2));
        demo.sortList(head);

        ListNode.print(head);*/

        /*Node head = new Node(1);
        Node node2 = new Node(2);
        head.next = node2;
        head.random = node2;
        node2.next = null;
        node2.random = node2;
        demo.copyRandomList(head);*/

        //4->2->1->3
        /*ListNode head = new ListNode(4);
        head.next(new ListNode(2)).next(new ListNode(1)).next(new ListNode(3));*/

        //-1->5->3->4->0
        /*ListNode head = new ListNode(-1);
        head.next(new ListNode(5)).next(new ListNode(3)).next(new ListNode(4)).next(new ListNode(0));
        demo.insertionSortList(head);*/

        /*ListNode head = new ListNode(1);
        head.next(new ListNode(2)).next(new ListNode(3))
                .next(new ListNode(4))
                .next(new ListNode(5))
                .next(new ListNode(6));
        demo.reverseBetween(head, 2,4 );

        ListNode.print(head);*/

        // -10, -3, 0, 5, 9
       /* ListNode head = new ListNode(-10);
        head
                .next(new ListNode(-3))
                .next(new ListNode(0))
                .next(new ListNode(5))
                .next(new ListNode(9))
                .next(new ListNode(10));
        demo.sortedListToBST(head);*/

        /*ListNode head = new ListNode(1);
        head
                .next(new ListNode(2))
                .next(new ListNode(3))
                .next(new ListNode(4))
                .next(new ListNode(5));
//        demo.rotateRight(head, 2);*/


        /*ListNode head = new ListNode(1);
        head
                .next(new ListNode(2))
                .next(new ListNode(3))
                .next(new ListNode(3))
                .next(new ListNode(4))
                .next(new ListNode(4))
                .next(new ListNode(5));
        ListNode listNode = demo.deleteDuplicates(head);
        ListNode.print(listNode);*/

//        System.out.println(demo.partitionLabels("ababcbacadefegdehijhklij"));

//        System.out.println(demo.findSubstring("barfoothefoobarman",
//                new String[]{"foo", "bar"}));

//        System.out.println(demo.findSubstring("wordgoodgoodgoodbestword",
//                new String[]{"word","good","best","good"}));

//        System.out.println(demo.reverseVowels("hello"));
//        System.out.println(demo.reverseVowels("leetcode"));

//        int diff = 'a' - 'A';
//        System.out.println(diff);

//        System.out.println(demo.isPalindrome("race a car"));
//        System.out.println(demo.isPalindrome("A man, a plan, a canal: Panama"));

//        System.out.println(demo.scoreOfParentheses("()"));
//        System.out.println(demo.scoreOfParentheses("((()))"));
//        System.out.println(demo.scoreOfParentheses("()()"));
//        System.out.println(demo.scoreOfParentheses("(()(()))"));
        /*TreeNode node = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        node.right = node2;
        node2.left = node3;
        demo.inorderTraversal(node);*/

        /*System.out.println(demo.numIslands(new char[][]{{'1', '0'}, {'0', '1'}}));
        System.out.println(demo.numIslands(new char[][]{
                {'1', '1', '1', '1', '0'},
                {'1', '1', '0', '1', '0'},
                {'1', '1', '0', '0', '1'},
                {'0', '0', '0', '1', '0'},
        }));*/

        /*System.out.println(demo.maxAreaOfIsland(new int[][]{
                {1, 1, 0, 0, 0},
                {1, 1, 0, 0, 0},
                {1, 0, 0, 1, 1},
                {0, 0, 0, 1, 1},
        }));*/

        /*System.out.println(demo.maxAreaOfIsland(new int[][]{
                {0, 1},
                {1, 0},
                {1, 0},
        }));*/

        /*System.out.println(demo.maxAreaOfIsland(new int[][]{
                {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},
                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
        }));*/

        /*System.out.println(demo.regionsBySlashes(new String[]{" /", "/ "}));
        System.out.println(demo.regionsBySlashes(new String[]{" /", "  "}));
        System.out.println(demo.regionsBySlashes(new String[]{"\\/", "/\\"}));
        System.out.println(demo.regionsBySlashes(new String[]{"/\\", "\\/"}));*/

        /*System.out.println(demo.trapRainWater(new int[][]{
                {1, 4, 3, 1, 3, 2},
                {3, 2, 1, 3, 2, 4},
                {2, 3, 3, 2, 3, 1},
        }));*/

        /*demo.print(demo.updateMatrix(new int[][]{
                {0, 0, 0},
                {0, 1, 0},
//                {0, 0, 0},
                {1, 1, 1},
        }));*/

        /*System.out.println(demo.pacificAtlantic(new int[][]{
         *//*{1, 2, 2, 3, 5},
                {3, 2, 3, 4, 4},
                {2, 4, 5, 3, 1},
                {6, 7, 1, 4, 5},
                {5, 1, 1, 2, 4},*//*
                {0}
        }));*/

        /*demo.print(demo.updateBoard(new char[][]{
                {'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'M', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E'},
        }, new int[]{3, 0}));*/

        /*demo.print(demo.updateBoard(new char[][]{
                {'B', '1', 'E', '1', 'B'},
                {'B', '1', 'M', '1', 'B'},
                {'B', '1', '1', '1', 'B'},
                {'B', 'B', 'B', 'B', 'B'},
        }, new int[]{1, 2}));*/

        /*demo.print(demo.updateBoard(new char[][]{
//        demo.print(demo.updateBoard_ii(new char[][]{
                {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}, {'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'}
                *//*{'E', 'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E', 'E'},
                {'E', 'E', 'E', 'E', 'E', 'E'},*//*
        }, new int[]{1, 2}));*/

//        demo.distanceK()

        /*System.out.println(demo.networkDelayTime(new int[][]{
                {2, 1, 1},
                {2, 3, 1},
                {3, 4, 1},
        }, 4, 2));*/

        /*System.out.println(Arrays.asList("!", "1"));
        System.out.println(String.join(",", Arrays.asList("!", "1")));

        System.out.println();*/

       /* System.out.println(demo.exist(new char[][]{
                {'A', 'B', 'C', 'E'},
                {'S', 'F', 'C', 'S'},
                {'A', 'D', 'E', 'E'},
//        }, "ABCCED"));
        }, "ABCB"));
//        }, "SEE"));*/
//
        /*System.out.println(demo.exist(new char[][]{
                {'a', 'b'},
                {'c', 'd'},
        }, "acdb"));*/

        System.out.println(Integer.valueOf("0022"));
    }

    public static void print(char[][] dp) {
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void print(int[][] dp) {
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void print(boolean[][] dp) {
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
    }

    public int ladderLength(String start, String end, Set<String> dict) {
        // write your code here
        if (start == null || end == null || dict.size() == 0) {
            return 0;
        }

        List<String> list = new ArrayList<>();
        list.add(start);
        list.add(end);
        list.addAll(dict);

        Map<String, int[]> map = new HashMap<>();
        toMap(map, list);

        Map<String, Set<String>> neighbers = new HashMap<>();
        toGraph(list, map, neighbers);

        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.add(start);
        visited.add(start);

        int ans = 0;
        int count = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();

            count += 1;

            for (int i = 0; i < size; i++) {
                String cur = queue.remove();
                if (end.equals(cur) && ans == 0) {
                    ans = count;
                }
                Set<String> neis = neighbers.get(cur);
                if (neis.size() > 0) {
                    for (String n : neis) {
                        if (visited.contains(n)) {
                            continue;
                        }
                        queue.add(n);
                        visited.add(n);
                    }
                }
            }
        }
        return ans;
    }

    private void toGraph(List<String> list, Map<String, int[]> map, Map<String, Set<String>> neighbers) {

        int len = list.size();
        String s1;
        String s2;
        for (int i = 0; i < len - 1; i++) {
            for (int j = 1; j < len; j++) {
                s1 = list.get(i);
                s2 = list.get(j);
                if (s1.equals(s2)) continue;
                if (oneLetterChange(map, s1, s2)) {
                    Set<String> n1 = neighbers.get(s1);
                    if (n1 == null) {
                        n1 = new HashSet<>();
                        neighbers.put(s1, n1);
                    }
                    n1.add(s2);

                    Set<String> n2 = neighbers.get(s2);
                    if (n2 == null) {
                        n2 = new HashSet<>();
                        neighbers.put(s2, n2);
                    }
                    n2.add(s1);
                }
            }
        }

    }

    private void toMap(Map<String, int[]> map, List<String> list) {
        for (String s : list)
            toMap(map, s);
    }

    private void toMap(Map<String, int[]> map, String s) {
        char[] cs = s.toCharArray();
        int[] letters = new int[26];
        for (char c : cs) {
            letters[c - 'a']++;
        }
        map.put(s, letters);
    }

    private boolean oneLetterChange(Map<String, int[]> map, String s, String o) {
        int count = 0;
        int[] ls = map.get(s);
        int[] lo = map.get(o);
        for (int i = 0; i < 26; i++) {
            if (ls[i] > 0 && lo[i] > 0) {
                System.out.println(ls[i] + ", " + lo[i] + " - " + (char) (i + 'a'));
                count += Math.min(ls[i], lo[i]);
            }
        }
        return count == s.length() - 1;
    }

    public String largestTimeFromDigits(int[] A) {
        if (A == null || A.length != 4) {
            return "";
        }

        Set<String> times = new HashSet<>();

        helper(times, A, new StringBuilder());

        System.out.println(times);

        String ans = null;
        for (String s : times) {
            if (s.compareTo("2359") > 0) {
                continue;
            }
            if (ans == null) {
                ans = s;
                continue;
            }
            if (s.compareTo(ans) > 0) {
                ans = s;
            }
        }
        return ans;
    }

    private void helper(Set<String> set, int[] A, StringBuilder result) {
        if (result.length() == A.length) {
            set.add(result.toString());
            return;
        }
        for (int i = 0; i < A.length; i++) {
            if (result.indexOf(A[i] + "") >= 0) {
                continue;
            }

            result.append(A[i]);
            helper(set, A, result);
            result.delete(result.length() - 1, result.length());
        }
    }

    public String[] reorderLogFiles(String[] logs) {
        if (logs == null || logs.length == 0) {
            return logs;
        }

        Arrays.sort(logs, (a, b) -> {
            String[] ca = a.split(" ");
            String[] cb = b.split(" ");


            boolean aLogType = Character.isDigit(ca[1].charAt(0));
            boolean bLogType = Character.isDigit(cb[1].charAt(0));

            if (aLogType && bLogType) {
                return 0;
            } else if (aLogType) {
                return 1;
            } else if (bLogType) {
                return -1;
            } else {
                int ans = a.substring(ca[0].length() + 1).compareTo(b.substring(cb[0].length() + 1));
                if (ans == 0) {
                    return a.substring(0, ca[0].length()).compareTo(b.substring(0, cb[0].length()));
                }
                return ans;
            }
        });
        return logs;
    }

    public void gameOfLife(int[][] board) {
        if (board == null || board.length == 0 || board[0].length == 0) {
            return;
        }

        int n = board.length;
        int m = board[0].length;

        /*
        old -> new[new , old]
        0   -> 10 | 00
        1   -> 11 | 01
        */
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                change(board, i, j, n, m);
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // update(board, i, j);
                board[i][j] >>= 1;
            }
        }
    }

    private static int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};
    private static int[] dx = {-1, -1, 0, 1, 1, 1, 0, -1};

    private void change(int[][] board, int i, int j, int n, int m) {
        int x = 0;
        int y = 0;
        int countLive = 0;
        for (int k = 0; k < 8; k++) {
            x = i + dx[k];
            y = j + dy[k];
            if (x < 0 || x >= n || y < 0 || y >= m) {
                continue;
            }
            if ((board[x][y] & 1) == 1) {
                countLive += 1;
            }
        }

        if (countLive == 3 || (countLive == 2 && (board[i][j] & 1) == 1)) {
            board[i][j] |= (1 << 1);
        }

    }

    public int firstMissingPositive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        /*
        把元素放置对应的位置上
        */
        for (int i = 0; i < n; i++) {
            while (nums[i] <= n && nums[i] > 0 && nums[i] != nums[nums[i] - 1]) {
                swap(nums, i, nums[i] - 1);
            }
        }

        for (int i = 0; i < n; i++) {
            if (i + 1 != nums[i]) {
                return i + 1;
            }
        }

        return n + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int ans = 0;
        /*
        空间换时间
        */
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            set.add(nums[i]);
        }

        for (int i = 0; i < n; i++) {
            if (!set.contains(nums[i] - 1)) {
                int j = nums[i];
                int curMax = 1;
                while (set.contains(++j)) {
                    curMax += 1;
                }
                ans = Math.max(ans, curMax);
            }
        }

        return ans;
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        if (candidates == null || candidates.length == 0 || target <= 0) {
            return ans;
        }
        Arrays.sort(candidates);

        helper(ans, candidates, 0, target, new ArrayList<>());

        return ans;
    }

    private void helper(List<List<Integer>> ans, int[] candidates, int startIdx, int target, ArrayList<Integer> result) {

        if (target == 0) {
            ans.add(new ArrayList<>(result));
            return;
        }

        for (int i = startIdx; i < candidates.length; i++) {

            if (target < candidates[i]) { // 提前剪枝，break,因为是升序的数组
                break;
            }

            if (i > 0 && candidates[i] == candidates[i - 1]) {
                continue;
            }

            result.add(candidates[i]);
            helper(ans, candidates, i, target - candidates[i], result);
            result.remove(result.size() - 1);
        }
    }

    public double myPow(double x, int n) {
        /*
        2^9
        4^4 * 2
        8^2 * 2
        64^1 * 2
        */
        if (x == 0) return 0d;
        long d = n;
        if (d < 0) {
            x = 1 / x;
            d = -d;
        }
        double rest = 1;
        while (d > 0) {
            if ((d & 1) == 1) rest *= x; // 奇数次幂 会多出一个x
            x *= x;
            d >>= 1;
        }
        return rest;
    }

    public List<Integer> countSmaller(int[] nums) {
        List<Integer> ans = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return ans;
        }

        int n = nums.length;
        int[] result = new int[n];
        /*单调递增栈*/
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {
                int curIdx = stack.pop();
                result[curIdx] = stack.size();
            }
            stack.push(i);
        }

        while (!stack.isEmpty()) {
            int curIdx = stack.pop();
            result[curIdx] = stack.size();
        }

        for (int i = 0; i < n; i++) {
            ans.add(result[i]);
        }
        return ans;
    }

    public int divide(int dividend, int divisor) {

        /*
        倍增的思想
        位移
        */

        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }

        boolean ne = (dividend ^ divisor) < 0; // 是否有一个是负数, true 负数， false 整数
        long a = Math.abs((long) dividend);
        long b = Math.abs((long) divisor);

        int ans = 0;

        while (a >= b) {
            int shift = 0;
            while (a >= (b << shift)) {
                shift += 1;
            }
            a -= b << (shift - 1); // shift 进入循环后再次加了1
            ans += 1 << (shift - 1);
        }

        return ne ? (int) -ans : (int) ans;
    }

    public int mySqrt(int x) {
        if (x <= 1) {
            return x;
        }

        long l = 1;
        long r = x / 2;
        long m = 0;
        long tmp = 0;
        while (l + 1 < r) {
            m = (r - l) / 2 + l;

            tmp = m * m;
            System.out.println(m + ", " + tmp);
            if (tmp == x) return (int) m;
            if (tmp < x) {
                l = m;
            } else {
                r = m;
            }
        }
        if (r * r <= x) return (int) r;
        if (l * l <= x) return (int) l;
        return 0;
    }

    public int splitArray(int[] nums, int m) {
        /*
        二分：
        l = max(nums[i]);
        r = sum(nums[i]);
        */
        if (nums == null || nums.length == 0 || nums.length < m) {
            return 0;
        }

        long l = 0;
        long r = 0;
        for (int i : nums) {
            l = Math.max(l, i);
            r += i;
        }

        int group = 0;
        long mid = 0;
        while (l + 1 < r) {
            mid = (r - l) / 2 + l;
            group = check(nums, mid);
            if (group > m) {//组分的太小
                l = mid;
            } else {
                r = mid;
            }
        }
        if (check(nums, l) <= m) return (int) l;
        return (int) r;
    }

    private int check(int[] nums, long block) {
        int group = 1;
        long sum = 0;
        for (int i : nums) {
            if (sum + i <= block) {
                sum += i;
            } else {
                sum = i;
                group += 1;
            }

            /*sum += i;
            if (sum > block) {
                sum = i;
                ++group;
            }*/

        }
        return group;
    }

    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int l = 0;
        int r = n - 1;
        int m = 0;
        while (l + 1 < r) {
            m = (r - l) / 2 + l;
            if (nums[m] == target) return m;
            // 找到第一个比target大的数字
            if (nums[m] < target) {
                l = m;
            } else {
                r = m;
            }
        }
        if (nums[l] >= target) return l;
        if (nums[r] >= target) return r;
        return n;
    }

    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        /*
        dp[i]表示以i结尾的子数组的最长上升子序列的长度
        dp[i] = dp[j] + 1 (nums[i - 1] >= nums[j - 1] | j in 0 ~ i -1)
        */

        int n = nums.length;
        int ans = 0;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i - 1] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j + 1] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }

    public int lengthOfLIS_II(int[] nums) {

        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int[] top = new int[n];

        print(nums);

        top[0] = nums[0]; // 第一个元素 ，init
        int idx = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i] > top[idx]) {// 需要开一个新的排列
                idx += 1;
                top[idx] = nums[i];
            } else {
                // 找到第一个大于或者等于 nums[i]的位置
                int insertIdx = findFirstGreaterElementIdx(top, idx, nums[i]);
                top[insertIdx] = nums[i];
            }
            print(top);
        }

        return idx + 1;
    }

    private void print(int[] dp) {
        for (int i = 0; i < dp.length; i++) {
            System.out.print(dp[i] + " ");
        }
        System.out.println();
    }

    private int findFirstGreaterElementIdx(int[] top, int idx, int target) {
        int l = 0;
        int r = idx;
        int m = 0;
        while (l + 1 < r) {
            m = (r - l) / 2 + l;
            if (top[m] >= target) {
                r = m;
            } else {
                l = m;
            }
        }
        if (top[l] >= target) {
            return l;
        } else {
            return r;
        }
    }

    public int maxSumSubmatrix(int[][] matrix, int K) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        int row = matrix.length;
        int col = matrix[0].length;

        int ans = Integer.MIN_VALUE;
        for (int i = 0; i < col; i++) {
            int[] prefix = new int[row];
            for (int j = i; j < col; j++) {   // 固定矩形的上下界
                for (int r = 0; r < row; r++) {
                    prefix[r] += matrix[r][j];
                }

                ans = Math.max(ans, helper(prefix, K));
            }
        }

        return ans;
    }

    // 数组中最大的子数组和 sum && sum <= k
    public int helper(int[] nums, int k) {
        /*
        prefix - k
        找到 第一个大于或等于 prefix - k的值即可 （排序好）
        */
        int ans = Integer.MIN_VALUE;
        int prefix = 0;
        TreeSet<Integer> set = new TreeSet<>();
        set.add(0);
        for (int i = 0; i < nums.length; i++) {
            prefix += nums[i];
            Integer val = set.ceiling(prefix - k);
            if (val != null) {
                ans = Math.max(ans, prefix - val);
            }
            set.add(prefix);
        }
        return ans;
    }

    public int maxEnvelopes(int[][] envelopes) {
        // write your code here
        if (envelopes == null || envelopes.length == 0 || envelopes[0].length == 0) {
            return 0;
        }

        // int ans = 0;
        int n = envelopes.length;
        Arrays.sort(envelopes, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });

        int[] top = new int[n];
        int len = 0;
        top[len] = envelopes[0][1];
        int[] tmp = null;
        for (int i = 1; i < n; i++) {
            tmp = envelopes[i];
            if (top[len] < tmp[1]) {
                len += 1;
                top[len] = tmp[1];
            } else {
                int idx = Arrays.binarySearch(top, 0, len, tmp[1]);
                if (idx < 0) {
                    idx = -idx - 1;
                }
                if (idx < n) {
                    top[idx] = tmp[1];
                }
            }
        }

        return len + 1;
    }

    public int maximalRectangle(char[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        int row = matrix.length;
        int col = matrix[0].length;
        int ans = 0;
        int[][] grid = builtGrid(matrix, row, col);
        for (int i = 0; i < row; i++) {
            ans = Math.max(ans, maxRec(grid[i], col));
        }
        return ans;
    }

    private int maxRec(int[] nums, int n) {

        int ans = 0;
        /*
        单调递增栈
        */
        Stack<Integer> stack = new Stack<>();
        // stack.push(-1);
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {
                int curIdx = stack.pop();
                int leftIdx = stack.isEmpty() ? -1 : stack.peek();
                int sum = (i - leftIdx - 1) * nums[curIdx];
                ans = Math.max(ans, sum);
            }
            stack.push(i);
        }

        while (!stack.isEmpty()) {
            int curIdx = stack.pop();
            int leftIdx = stack.isEmpty() ? -1 : stack.peek();
            int sum = (n - leftIdx - 1) * nums[curIdx];
            ans = Math.max(ans, sum);
        }
        System.out.println(" ---- ---------");
        print(nums);
        System.out.println(ans);
        System.out.println(" ---- ---------");
        return ans;
    }

    // 前缀和
    private int[][] builtGrid(char[][] matrix, int row, int col) {
        int[][] grid = new int[row][col];
        for (int j = 0; j < col; j++) {
            grid[0][j] = matrix[0][j] - '0';
        }
        for (int i = 1; i < row; i++) {
            for (int j = 0; j < col; j++) {
                grid[i][j] = matrix[i][j] == '0' ? 0 : (grid[i - 1][j] + 1);
            }
        }
        return grid;
    }

    public boolean isHappy(int n) {
        if (n <= 0) return false;
        Set<Integer> set = new HashSet<>();

        do {
            set.add(n);
            int sum = 0;
            while (n > 0) {
                int a = n % 10;
                sum += a * a;
                n = n / 10;
            }
            n = sum;
            System.out.println(set);
        } while (!set.contains(n));

        return n == 1;
    }

    public int[] topKFrequent(int[] nums, int k) {

        if (nums == null || nums.length == 0 || k <= 0) {
            return new int[0];
        }

        Map<Integer, Integer> count = new HashMap<>();
        for (int i : nums) {
            count.put(i, count.getOrDefault(i, 0) + 1);
        }
        // 小堆
        PriorityQueue<Integer> heap = new PriorityQueue<>(k, (a, b) -> count.get(a) - count.get(b));

        for (int i : count.keySet()) {
            heap.add(i);
            if (heap.size() > k) {
                heap.poll();
            }
        }

        System.out.println(heap);

        int[] ans = new int[heap.size()];
        int idx = 0;
        while (heap.size() > 0)
            ans[idx++] = heap.poll();

        return ans;
    }

    public boolean containsNearbyDuplicate(int[] nums, int k) {
        /*
        map + 遍历
        */
        if (nums == null || nums.length == 0 || k <= 0) {
            return false;
        }
        int n = nums.length;
        Map<Integer, Integer> indexMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (indexMap.get(nums[i]) != null) {
                if (Math.abs(indexMap.get(nums[i]) - i) <= k) {
                    return true;
                }
            }
            indexMap.put(nums[i], i);
        }
        return false;
    }


    public String[] findWords(String[] words) {
        if (words == null || words.length == 0) {
            return null;
        }
        List<String> result = new ArrayList<>();

        char[] cs = null;
        for (String w : words) {
            boolean hasOne = false;
            boolean hasTwo = false;
            boolean hasThree = false;

            boolean uni = true;
            cs = w.toCharArray();
            for (char c : cs) {
                if (mapOne[c] > 0) {
                    hasOne = true;
                    if (hasTwo || hasThree) {
                        uni = false;
                        break;
                    }
                } else if (mapTwo[c] > 0) {
                    hasTwo = true;
                    if (hasOne || hasThree) {
                        uni = false;
                        break;
                    }
                } else {
                    hasThree = true;
                    if (hasTwo || hasOne) {
                        uni = false;
                        break;
                    }
                }
            }

            if (uni) result.add(w);
        }


        String[] ans = new String[result.size()];
        for (int i = 0; i < result.size(); i++) {
            ans[i] = result.get(i);
        }

        return ans;
    }

    private static char[] lineOne = {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'};
    private static char[] lineTwo = {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'};
    private static char[] lineThree = {'z', 'x', 'c', 'v', 'b', 'n', 'm', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'};
    private static int[] mapOne = new int[128];
    private static int[] mapTwo = new int[128];
    private static int[] mapThree = new int[128];

    static {
        toMap(mapOne, lineOne);
        toMap(mapTwo, lineTwo);
        toMap(mapThree, lineThree);
    }

    public static void toMap(int[] map, char[] cs) {
        for (char c : cs) {
            map[c]++;
        }
    }

    public ListNode sortList_II(ListNode head) {
        // write your code here
        /*merge sort*/
        if (head == null || head.next == null) {
            return head;
        }
        ListNode slow = head;
        ListNode fast = head;
        // 之所以要判断 fast.next != null ，因为要取mid的前一个节点，需要断开为两个子链表
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode mid = slow.next;
        slow.next = null; // 断为两截

        ListNode left = sortList(head);
        ListNode right = sortList(mid);

        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;

        while (left != null && right != null) {
            if (left.val > right.val) {
                cur.next = right;
                right = right.next;
            } else {
                cur.next = left;
                left = left.next;
            }
            cur = cur.next;
        }
        cur.next = (left == null) ? right : left;
        return dummyHead.next;
    }

    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode midPre = findMiddle(head);
        ListNode mid = midPre.next;
        midPre.next = null;

        ListNode left = sortList(head);
        ListNode right = sortList(mid);
        return merge(left, right);
    }

    private ListNode merge(ListNode left, ListNode right) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;

        while (left != null && right != null) {
            if (left.val > right.val) {
                cur.next = right;
                right = right.next;
            } else {
                cur.next = left;
                left = left.next;
            }
            cur = cur.next;
        }

        cur.next = (left == null) ? right : left;

        return dummyHead.next;
    }

    private ListNode findMiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public Node copyRandomList(Node head) {
        if (head == null) {
            return head;
        }

        /*
        A -> B -> C
        A -> A' -> B -> B' -> C -> C'
        1：将复制的新节点放到当前节点后
        2：修改新节点的随机指针
        3：挑出新节点返回
        */

        Node cur = head;
        while (cur != null) {

            Node newNode = new Node(cur.val);

            newNode.next = cur.next;
            cur.next = newNode;

            cur = newNode.next;
        }

        cur = head;
        while (cur != null) {
            if (cur.random != null) {
                cur.next.random = cur.random.next;
            }
            cur = cur.next.next;
        }

        cur = head;

        Node dummyHead = head.next;
        Node curNew = dummyHead;

        while (cur != null) {
            cur.next = curNew.next;

            cur = cur.next;

            if (curNew.next != null)
                curNew.next = cur.next;

            curNew = curNew.next;
        }

        return dummyHead;
    }

    static class Node {
        int val;
        Node next;
        Node random;

        public Node(int val) {
            this.val = val;
            this.next = null;
            this.random = null;
        }
    }


    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode dummyHead = new ListNode(0);

        ListNode cur = head;

        while (cur != null) {

            ListNode next = cur.next;

            cur.next = null;
            insert(dummyHead, cur);

            cur = next;
        }
        return dummyHead.next;
    }

    private void insert(ListNode dummyHead, ListNode node) {
        ListNode pre = dummyHead.next;

        if (pre == null) { // 只有一个虚拟节点时
            dummyHead.next = node;
            return;
        }

        if (pre.val >= node.val) {// 新节点的元素小于第一个节点的元素
            dummyHead.next = node;
            node.next = pre;
            return;
        }

        while (pre != null) {
            ListNode cur = pre.next;
            if (cur == null) {
                pre.next = node;
                break;
            }
            if (cur.val < node.val) {
                pre = cur;
                continue;
            }
            pre.next = node;
            node.next = cur;
            break;
        }
    }

    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (head == null || head.next == null || m > n) {
            return head;
        }

        ListNode dummyHead = new ListNode(0);// 用一个新的虚拟头结点，是防止从第一个元素开始翻转
        dummyHead.next = head;

        ListNode cur = dummyHead;
        /*
        第一个段的结尾
        第二段的新的开头和 结尾的下一个节点是相连的
        */
        ListNode firstTail = null;
        int idx = 1;
        while (idx < m) {
            cur = cur.next;
            idx += 1;
        }

        firstTail = cur;
        cur = cur.next;
        firstTail.next = null;

        ListNode secTail = cur;
        ListNode secHead = null;
        while (idx <= n) {//cur != null){
            ListNode next = cur.next;

            cur.next = secHead;
            secHead = cur;

            cur = next;
            idx += 1;
        }

        // cur 表示 第n个元素后的节点
        firstTail.next = secHead;
        secTail.next = cur;

        return dummyHead.next;
    }

    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) {
            return null;
        }
        List<Integer> datas = values(head);
        return toBst(datas, 0, datas.size() - 1);
    }

    private TreeNode toBst(List<Integer> list, int start, int end) {
        if (start > end) return null;
        int mid = (end - start) / 2 + start;
        TreeNode root = new TreeNode(list.get(mid));
        if (start == end) return root;

        root.left = toBst(list, start, mid - 1);
        root.right = toBst(list, mid + 1, end);
        return root;
    }

    private List<Integer> values(ListNode head) {
        List<Integer> list = new ArrayList<>();
        ListNode cur = head;

        while (cur != null) {
            list.add(cur.val);
            cur = cur.next;
        }
        return list;
    }

    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k < 0) {
            return head;
        }

        int len = getListLength(head);
        k = k % len;
        if (k == 0) return head;

        /*
        找到第一段的尾部，断开
        翻转两部分，连接
        再次翻转
        */
        ListNode cur = head;
        int count = len - k;
        while (count > 1) {
            cur = cur.next;
            count -= 1;
        }
        System.out.println(cur.val);

        ListNode right = cur.next;
        cur.next = null;


        print(head);
        print(right);

        ListNode newLeftTail = head;

        ListNode newLeft = reverse(head);
        ListNode newRight = reverse(right);

        newLeftTail.next = newRight;

        ListNode newHead = reverse(newLeft);

        System.out.println(" ===== ");
        print(newLeft);
        print(newRight);
        print(newHead);

        return newHead;
    }

    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode newHead = null;
        ListNode cur = head;

        while (cur != null) {
            ListNode next = cur.next;

            cur.next = newHead;
            newHead = cur;

            cur = next;
        }

        return newHead;
    }

    private int getListLength(ListNode head) {
        int len = 0;
        while (head != null) {
            head = head.next;
            len += 1;
        }
        return len;
    }

    void print(ListNode head) {
        while (head != null) {
            System.out.print(head.val + ", ");
            head = head.next;
        }
        System.out.println();
    }

    /*
    *   输入: 1->2->3->3->4->4->5
        输出: 1->2->5
    * */
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode dummyHead = new ListNode(0);
        ListNode curNew = dummyHead;

        ListNode cur = head;

        ListNode point = null; // 保存重复点
        while (cur != null) {
            ListNode next = cur.next;
            if (next == null) {
                break;
            }

            // next != null
            if (cur.val == next.val) {
                point = cur;
                cur.next = next.next;
            } else {
                if (point == null || point.val != cur.val) {
                    curNew.next = cur;
                    cur.next = null;

                    curNew = curNew.next;
                }
                cur = next;
            }
        }

        if (point != null && point.val != cur.val) {
            curNew.next = cur;
            cur.next = null;
        }

        return dummyHead.next;
    }

    public List<Integer> partitionLabels(String S) {
        List<Integer> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return ans;
        }

        char[] cs = S.toCharArray();

        int n = S.length();
        int[] map = new int[26];
        for (int i = 0; i < n; i++) {
            map[cs[i] - 'a'] = i;
        }

        TreeMap<Character, Integer> treeMap = new TreeMap<>();
        for (int i = 0; i < map.length; i++) {
            if (map[i] == 0) continue;
            treeMap.put((char) (i + 'a'), map[i]);
        }

        int l = 0;
        int r = 0;

        while (l < n) {

            int lastIdx = treeMap.get(cs[l]);
            r = lastIdx;
            for (int i = l; i <= lastIdx; i++) {
                int tmpLastIdx = treeMap.get(cs[i]);
                if (tmpLastIdx > lastIdx) {
                    lastIdx = tmpLastIdx;
                    r = lastIdx;
                }
            }

            if (lastIdx == r) {
                ans.add(r - l + 1);
            }
            l = r + 1;
        }
        return ans;
    }

    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        if (s == null || s.length() == 0 || words.length == 0) {
            return ans;
        }
        int l = words[0].length();
        int len = l * words.length;
        Map<String, Integer> count = new HashMap<>();
        for (String w : words) {
            count.put(w, count.getOrDefault(w, 0) + 1);
        }

        int n = s.length();
        Map<String, Integer> map = map = new HashMap<>();
        for (int i = 0; i + len <= n; i++) {
            map.clear();
            int j = i;
            for (j = i; j < i + len; j += l) {
                String tmp = s.substring(j, j + l);
                if (count.get(tmp) != null) {
                    map.put(tmp, map.getOrDefault(tmp, 0) + 1);
                    if (map.get(tmp) > count.get(tmp)) {
                        break;
                    }
                } else {
                    break;
                }
            }
            System.out.println(j + ", " + i);
            if (j == i + len) {
                ans.add(i);
            }
        }
        return ans;
    }

    private static int[] map = new int[128];
    private static String letters = "aoeiuAOEIU";

    {
        for (char c : letters.toCharArray()) {
            map[c] = 1;
        }
    }

    public String reverseVowels(String s) {
        if (s == null || s.length() == 0) {
            return s;
        }

        char[] cs = s.toCharArray();
        int l = 0, r = cs.length - 1;
        while (l < r) {
            if (map[cs[l]] > 0 && map[cs[r]] > 0) {
                swap(cs, l++, r--);
            } else if (map[cs[l]] == 0) {
                l++;
            } else {
                r--;
            }
        }

        return new String(cs);
    }

    private void swap(char[] cs, int i, int j) {
        System.out.println(i + ", " + j);
        char c = cs[i];
        cs[i] = cs[j];
        cs[j] = c;
    }

    private static int diff = 'a' - 'A';

    public boolean isPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }
        char[] cs = s.toCharArray();
        // 双指针
        int n = s.length(), l = 0, r = n - 1;
        while (l <= r) {
            if (!Character.isLetterOrDigit(cs[l])) {
                l++;
            } else if (!Character.isLetterOrDigit(cs[r])) {
                r--;
            } else {
                System.out.println(cs[l] + ", " + cs[r]);
                if (Character.toLowerCase(cs[l]) == Character.toLowerCase(cs[r])) {
                    l++;
                    r--;
                } else {
                    return false;
                }
            }
        }

        return true;
    }

    public int scoreOfParentheses(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        char[] cs = s.toCharArray();
        Stack<Character> stack = new Stack<>();

        char c = ' ';
        for (int i = 0; i < cs.length; i++) {
            c = cs[i];
            if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                char tmp = stack.pop();
                if (tmp == '(') {
                    stack.push('1');
                } else {
                    // tmp 是 数字
                    char tmp2 = stack.pop();
                    if (tmp2 == '(') {
                        stack.push((char) ((tmp - '0') * 2 + '0'));
                    } else {
                        // tmp2 是 数字
                        stack.push((char) ((tmp - '0') + tmp2));
                        i = i - 1;
                    }

                    while (!stack.isEmpty() && Character.isDigit(stack.peek())) {

                    }
                }
            }
        }

        return stack.peek() - '0';
    }

    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }

        TreeMap<Integer, Integer> map = new TreeMap<>((a, b) -> b - a); // value : index
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            map.put(nums[i], i);
        }

        return helper(nums, map, 0, n - 1);
    }

    private TreeNode helper(int[] nums, TreeMap<Integer, Integer> map, int l, int r) {
        if (l > r) {
            return null;
        }

        Map.Entry<Integer, Integer> first = map.pollFirstEntry();
        TreeNode root = new TreeNode(first.getKey());
        int rootIdx = first.getValue();
        root.left = helper(nums, map, l, rootIdx - 1);
        root.right = helper(nums, map, rootIdx + 1, r);

        return root;
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();

        Deque<Node2> stack = new LinkedList<>();
        stack.add(new Node2(root, 0));
        while (!stack.isEmpty()) {
            Node2 tmp = stack.pop();
            TreeNode treeNode = tmp.treeNode;
            if (treeNode == null) {
                continue;
            }
            if (tmp.flag == 1) {
                ans.add(tmp.treeNode.val);
                continue;
            }

            stack.add(new Node2(treeNode.right, 0));
            stack.add(new Node2(treeNode, 1));
            stack.add(new Node2(treeNode.left, 0));
        }

        return ans;
    }

    class Node2 {
        public TreeNode treeNode;
        public int flag; //0 - add ,1 - print

        public Node2(TreeNode treeNode, int flag) {
            this.treeNode = treeNode;
            this.flag = flag;
        }
    }

    public int numIslands(char[][] grid) {
        /*
        bfs
        */
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int row = grid.length;
        int col = grid[0].length;

        int count = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == '1') {
                    count += 1;
                    dfs(grid, i, j);
                }
            }
        }

        return count;
    }

    private void dfs(char[][] grid, int i, int j) {
        int r = grid.length;
        int c = grid[0].length;

        if (i < 0 || j < 0 || i >= r || j >= c) {
            return;
        }

        grid[i][j] = '0';
        for (int k = 0; k < 4; k++) {
            int x = dx2[k] + i;
            int y = dy2[k] + j;
            if (x < 0 || y < 0 || x >= r || y >= c) continue;
            if (grid[x][y] == '1')
                dfs(grid, x, y);
        }
    }

    private static int[] dx2 = {0, 1, 0, -1};
    private static int[] dy2 = {1, 0, -1, 0};

    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        /*
        bfs
        */

        int row = grid.length;
        int col = grid[0].length;
        int ans = 0;
        int x = 0, y = 0;
        UF uf = new UF(row * col);
        boolean[][] visited = new boolean[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 0)
                    continue;

                visited[i][j] = true;

                for (int d = 0; d < dx3.length; d++) {
                    x = dx3[d] + i;
                    y = dy3[d] + j;
                    if (x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0 || visited[x][y]) {
                        continue;
                    }
                    uf.union(i * col + j, x * col + y);
                }
            }
        }

        for (int i = 0; i < row * col; i++) {
            ans = Math.max(ans, uf.getSize()[i]);
        }

        return ans;
    }

    class UF {
        int[] size;
        int[] id;

        public UF(int n) {
            id = new int[n];
            for (int i = 0; i < n; i++) {
                id[i] = i;
            }
            size = new int[n];
            Arrays.fill(size, 1);
        }

        public int find(int p) {
            if (p == id[p]) {
                return p;
            }
            return id[p] = find(id[p]);

            /*while (p != id[p]) {
                id[p] = id[id[p]];
                p = id[p];
            }
            return p;*/
        }

        public void union(int p, int q) {
            int pid = find(p);
            int qid = find(q);
            if (pid == qid) return;
            if (size[pid] > size[qid]) {
                id[qid] = pid;
                size[pid] += size[qid];
            } else {
                id[pid] = qid;
                size[qid] += size[pid];
            }
        }

        public int[] getSize() {
            return size;
        }

        public int[] getId() {
            return id;
        }
    }

    // private static int[] dx = {-1, 0, 1, 0};
    // private static int[] dy = {0, 1, 0, -1};

    private static int[] dx3 = {0, 1};
    private static int[] dy3 = {1, 0};

    public int regionsBySlashes(String[] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int row = grid.length;
        int col = grid[0].split("").length;

        int n = 4 * row * col;
        /*
        单个格子分为4块： 0- 上； 1-右；2-下；3- 左
        */
        UF uf = new UF(n);
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                int idx = 4 * (i * col + j);
                // 合并单个格子
                switch (grid[i].charAt(j)) {
                    case '/':
                        uf.union(idx + 0, idx + 3);
                        uf.union(idx + 1, idx + 2);
                        break;
                    case '\\':
                        uf.union(idx + 0, idx + 1);
                        uf.union(idx + 2, idx + 3);
                        break;
                    case ' ':
                        uf.union(idx + 0, idx + 1);
                        uf.union(idx + 1, idx + 2);
                        uf.union(idx + 2, idx + 3);
                        break;
                }
                if (j + 1 < col) { // 向右合并相邻的格子
                    uf.union(idx + 1, idx + 4 + 3);
                }
                if (i + 1 < row) {// 向下合并相邻的格子
                    uf.union(idx + 2, idx + 4 * col + 0);
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (uf.getId()[i] == i) {
                ans += 1;
            }
        }

        return ans;
    }

    public int numSquares(int n) {
        if (n <= 0) {
            return 0;
        }
        if (n == 1) {
            return n;
        }
        /*
        背包型 dp
        背包大小为n, 物品数为 n / 2;
        dp[n]
        dp[i] 表示前i个物品能够拼成j的最小个数
        dp[i] = min(dp[j] | i - k * k >= 0) + 1;
        */
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }

    public int trapRainWater(int[][] heightMap) {
        /*
        bfs 遍历，如果当前节点比四周的邻居都小，表示可以接住雨水
        */
        if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0) {
            return 0;
        }

        int rows = heightMap.length;
        int cols = heightMap[0].length;
        PriorityQueue<Cell> heap = new PriorityQueue<>(
                (a, b) -> a.height - b.height
        );
        boolean[][] visited = new boolean[rows][cols];
        // 将四周一圈的边放入堆中（这些格子一定接不到水）
        for (int i = 0; i < rows; i++) {
            visited[i][0] = true;
            visited[i][cols - 1] = true;
            heap.add(new Cell(i, 0, heightMap[i][0]));
            heap.add(new Cell(i, cols - 1, heightMap[i][cols - 1]));
        }

        for (int i = 0; i < cols; i++) {
            visited[0][i] = true;
            visited[rows - 1][i] = true;
            heap.add(new Cell(0, i, heightMap[0][i]));
            heap.add(new Cell(rows - 1, i, heightMap[rows - 1][i]));
        }

        int ans = 0;
        while (!heap.isEmpty()) {
            Cell cell = heap.poll();
            int r = cell.row, c = cell.col, h = cell.height;

            for (int i = 0; i < dx2.length; i++) {
                int x = r + dx2[i];
                int y = c + dy2[i];
                if (x < 1 || y < 1 || x >= rows - 1 || y >= cols - 1
                        || visited[x][y]) {
                    continue;
                }
                if (h > heightMap[x][y]) {
                    ans += h - heightMap[x][y];
                }
                heap.add(new Cell(x, y, Math.max(h, heightMap[x][y])));
                visited[x][y] = true;
            }
        }
        return ans;
    }

    class Cell {
        int height;
        int row;
        int col;

        public Cell(int row, int col, int height) {
            this.height = height;
            this.row = row;
            this.col = col;
        }
    }

    public int[][] updateMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return new int[0][0];
        }

        int n = matrix.length;
        int m = matrix[0].length;
        /*
        bfs 宽搜
        */
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 0) {
                    queue.add(new int[]{i, j});
                    visited[i][j] = true;
                }
            }
        }

        int times = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] pair = queue.poll();
                matrix[pair[0]][pair[1]] = times;
                for (int d = 0; d < dx2.length; d++) {
                    int x = pair[0] + dx2[d];
                    int y = pair[1] + dy2[d];
                    if (x < 0 || y < 0 || x >= n || y >= m || matrix[x][y] == 0 || visited[x][y]) {
                        continue;
                    }

                    visited[x][y] = true;
                    queue.add(new int[]{x, y});
                }
            }

            times++;
        }

        return matrix;
    }

    public List<List<Integer>> pacificAtlantic(int[][] matrix) {
        /*
        宽搜
        分别从右下，和左上开始
        然后求交集
        */
        List<List<Integer>> ans = new ArrayList<>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return ans;
        }
        int row = matrix.length;
        int col = matrix[0].length;

        Queue<int[]> queuePA = new LinkedList<>();
        boolean[][] visitedPA = new boolean[row][col];

        Queue<int[]> queueAT = new LinkedList<>();
        boolean[][] visitedAT = new boolean[row][col];

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (i == 0 || j == 0) {
                    queuePA.add(new int[]{i, j});
                    visitedPA[i][j] = true;
                }
                if (i == row - 1 || j == col - 1) {
                    queueAT.add(new int[]{i, j});
                    visitedAT[i][j] = true;
                }
            }
        }

        bfs(matrix, visitedAT, row, col, queueAT);
        bfs(matrix, visitedPA, row, col, queuePA);

        System.out.println(" ========== ");
        print(visitedAT);
        System.out.println(" ========== ");
        print(visitedPA);
        System.out.println(" ========== ");
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (visitedAT[i][j] && visitedPA[i][j]) {
                    ans.add(Arrays.asList(i, j));
                }
            }
        }

        return ans;
    }

    private void bfs(int[][] matrix, boolean[][] visited, int row, int col, Queue<int[]> queue) {

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] pair = queue.poll();
                for (int d = 0; d < dx2.length; d++) {
                    int x = dx2[d] + pair[0];
                    int y = dy2[d] + pair[1];
                    if (x < 0 || y < 0 || x >= row || y >= col || matrix[x][y] < matrix[pair[0]][pair[1]] || visited[x][y]) {
                        continue;
                    }
                    queue.add(new int[]{x, y});
                    visited[x][y] = true;
                }
            }
        }
    }

    public char[][] updateBoard(char[][] board, int[] click) {
        if (board == null || board.length == 0 || board[0].length == 0
                || click == null || click.length == 0) {
            return board;
        }

        /*
        深搜
        宽搜
        都可
        */
        int r = click[0];
        int c = click[1];
        if (board[r][c] == 'M') {
            board[r][c] = 'X';
            return board;
        }
        if (board[r][c] == 'B') {
            return board;
        }
        int row = board.length;
        int col = board[0].length;
        // E
        Queue<int[]> queue = new LinkedList<>();
        queue.add(click);
        while (!queue.isEmpty()) {
            int size = queue.size();
            System.out.println(queue.size() + " ====== ");
            for (int i = 0; i < size; i++) {

                int[] pair = queue.poll();
                if (board[pair[0]][pair[1]] == 'B') continue;

                board[pair[0]][pair[1]] = 'B';

                int count = count(board, pair, row, col);
                if (count > 0) {
                    board[pair[0]][pair[1]] = (char) (count + '0');
                    continue;
                }


                for (int d = 0; d < dx.length; d++) {
                    int x = dx[d] + pair[0];
                    int y = dy[d] + pair[1];
                    if (x < 0 || y < 0 || x >= row || y >= col) {
                        continue;
                    }
                    if (board[x][y] == 'E') {
                        queue.add(new int[]{x, y});
                    }
                }
            }
        }
        return board;
    }

    private int count(char[][] board, int[] pair, int row, int col) {
        int m = 0;
        for (int d = 0; d < dx.length; d++) {
            int x = dx[d] + pair[0];
            int y = dy[d] + pair[1];
            if (x < 0 || y < 0 || x >= row || y >= col) {
                continue;
            }
            if (board[x][y] == 'M') {
                m += 1;
            }
        }
        return m;
    }

    public char[][] updateBoard_ii(char[][] board, int[] click) {
        int r = board.length;
        int c = board[0].length;
        Queue<Node3> queue = new LinkedList<>();
        queue.offer(new Node3(click[0], click[1]));
        while (!queue.isEmpty()) {
            Node3 top = queue.poll();
            int x = top.x;
            int y = top.y;
            if (board[x][y] == 'E') { // 如果当前为E，才进行判断是否要递归相邻结点
                board[x][y] = 'B';
                int count = judge(board, x, y);
                if (count == 0) { // 如果为0，则进行递归（感觉这里可以与jude进行优化，但是反而时间增加了，以后再优化吧==）
                    for (int i = 0; i < 8; i++) {
                        int newX = x + dx[i];
                        int newY = y + dy[i];
                        if (newX < 0 || newX >= r || newY < 0 || newY >= c) {
                            continue;
                        }
                        queue.offer(new Node3(newX, newY));
                    }
                } else { // 如果不为0，则不加入队列，同时更新当前结点的值为地雷数量
                    board[x][y] = (char) (count + '0');
                }
            } else if (board[x][y] == 'M') { // 如果当前为M，则只更新当前结点
                board[x][y] = 'X';
            }
        }
        return board;
    }

    // 获取当前借点相邻的地雷数量
    public int judge(char[][] board, int x, int y) {
        int r = board.length;
        int c = board[0].length;
        int count = 0;
        for (int i = 0; i < 8; i++) {
            int newX = x + dx[i];
            int newY = y + dy[i];
            if (newX < 0 || newX >= r || newY < 0 || newY >= c) {
                continue;
            }
            if (board[newX][newY] == 'M') {
                count++;
            }
        }
        return count;
    }

    static class Node3 {
        int x;
        int y;

        Node3(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
        /*
        宽搜
        用 map 作为图，每个保存每个节点的孩子节点和父节点
        */
        List<Integer> ans = new ArrayList<>();
        if (root == null || target == null) {
            return ans;
        }

        Map<TreeNode, List<TreeNode>> map = builtMap(root);

        int distance = 0;
        Queue<TreeNode> queue = new LinkedList<>();
        Set<TreeNode> visited = new HashSet<>();
        queue.add(target);
        visited.add(target);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                List<TreeNode> tmp = map.get(queue.poll());
                for (TreeNode node : tmp) {
                    if (visited.contains(node)) {
                        continue;
                    }
                    if (distance == K) {
                        ans.add(node.val);
                    }
                    visited.add(node);
                    queue.add(node);
                }
            }
            if (distance == K) {
                break;
            }
            if (!queue.isEmpty()) {
                distance += 1;
            }
        }
        return ans;
    }

    private Map<TreeNode, List<TreeNode>> builtMap(TreeNode root) {
        Map<TreeNode, List<TreeNode>> map = new HashMap<>();
        if (root == null) {
            return map;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            TreeNode left = node.left;
            TreeNode right = node.right;
            List<TreeNode> rootList = getList(map, node);
            if (left != null) {
                rootList.add(left);
                List<TreeNode> leftList = getList(map, left);
                leftList.add(node);
            }
            if (right != null) {
                rootList.add(right);
                List<TreeNode> rightList = getList(map, right);
                rightList.add(node);
            }
        }
        return map;
    }

    private List<TreeNode> getList(Map<TreeNode, List<TreeNode>> map, TreeNode node) {

        List<TreeNode> list = map.get(node);
        if (list == null) {
            list = new ArrayList<>();
            map.put(node, list);
        }
        return list;
    }

    public int networkDelayTime(int[][] times, int N, int K) {
        /*
        图
        宽搜
        访问后标记，用时间来标记，如果遍历完成之后，还有没有访问的点，返回-1
        */
        if (times == null || times.length == 0 || times[0].length == 0 || N <= 0 || N < K) {
            return -1;
        }

        Map<Integer, List<int[]>> neiberMap = builtMap(times);
        Map<Integer, Integer> distanceMap = new HashMap<>();

        // int[]{距离，节点}
        PriorityQueue<int[]> heap = new PriorityQueue<>(
                (a, b) -> a[0] - b[0]
        );
        heap.add(new int[]{0, K});
        while (!heap.isEmpty()) {
            int[] pair = heap.poll();
            int d = pair[0], curNode = pair[1];
            if (distanceMap.containsKey(curNode)) continue;

            distanceMap.put(curNode, d);

            List<int[]> neiberList = neiberMap.get(curNode);
            if (neiberList == null) continue;
            for (int[] nei : neiberList) {
                int neiNode = nei[0];
                int dis = nei[1];
                if (distanceMap.containsKey(neiNode)) continue;
                heap.add(new int[]{d + dis, neiNode});
            }
        }
        if (distanceMap.size() != N) return -1;
        int ans = 0;
        for (Map.Entry<Integer, Integer> en : distanceMap.entrySet()) {
            ans = Math.max(ans, en.getValue());
        }

        return ans;
    }

    private Map<Integer, List<int[]>> builtMap(int[][] times) {
        Map<Integer, List<int[]>> map = new HashMap<>();
        for (int[] t : times) {
            List<int[]> list = map.get(t[0]);
            if (list == null) {
                list = new ArrayList<>();
                map.put(t[0], list);
            }
            list.add(new int[]{t[1], t[2]});
        }
        return map;
    }


    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) {
            return false;
        }

        int row = board.length;
        int col = board[0].length;

        char[] cw = word.toCharArray();

        List<int[]> startList = new ArrayList<>();
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (board[i][j] == cw[0]) {
                    startList.add(new int[]{i, j});
                }
            }
        }

        if (startList.size() == 0) return false;

        for (int[] pair : startList) {
            boolean[][] visited = new boolean[row][col];
            visited[pair[0]][pair[1]] = true;
            if (helper(board, cw, pair[0], pair[1], row, col, 0, visited)) {
                return true;
            }
        }

        return false;
    }

    private boolean helper(char[][] board, char[] cw, int i, int j,
                           int row, int col, int index, boolean[][] visited) {
        if (index + 1== cw.length) {
            return true;
        }
        boolean find = false;
        for (int d = 0; d < dx2.length; d++) {
            int x = dx2[d] + i;
            int y = dy2[d] + j;
            if (x < 0 || y < 0 || x >= row || y >= col || visited[x][y]) {
                continue;
            }

            if (cw[index + 1] != board[x][y]) {
                continue;
            }
            visited[x][y] = true;
            find |= helper(board, cw, x, y, row, col, index + 1, visited);
            visited[x][y] = false;
        }
        return find;
    }
}