#### synchronized 和 ReentrantLock 的选择

　　在一些内置锁无法满足需求的情况下，ReentrantLock 可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用synchronized。

#### CHL 队列锁 [linked](https://www.cnblogs.com/sanzao/p/10567529.html)

#####一、自旋锁简介

通常情况下解决多线程共享资源逻辑一致性问题有两种方式：

- 互斥锁：当发现资源被占用的时候，会阻塞自己直到资源解除占用，然后再次尝试获取；
- 自旋锁：当发现占用时，一直尝试获取锁（线程没有被挂起的过程，也就没有线程调度切换的消耗）；

对于这两种方式没有优劣之分，只有是否适合当前的场景；

但是如果竞争非常激烈的时候，使用自旋锁就会产生一些额外的问题：

- 可能导致一些线程始终无法获取锁（争抢的时候必然是当前活跃线程获得锁的几率大），也就是饥饿现象；
- 因为自旋锁会依赖一个共享的锁标识，所以竞争激烈的时候，锁标识的同步也需要消耗大量的资源；
- 如果要用自旋锁实现公平锁（即先到先获取），此时就还需要额外的变量，也会比较麻烦；

解决这些问题其中的一种办法就是使用队列锁，简单来讲就是让这些线程排队获取；下面我们介绍常用的两种，即 

二 、**CLH 锁** 和 **MCS 锁**；

核心思想是：通过一定手段将所有线程对某一共享变量的轮询竞争转化为一个线程队列，且队列中的线程各自轮询自己的本地变量。

CLH锁的核心思想是将众多线程长时间对某资源的竞争，通过有序化这些线程将其转化为只需对本地变量检测。而唯一存在竞争的地方就是在入队列之前对尾节点tail的竞争，但此时竞争的线程数量已经少了很多了。比起所有线程直接对某资源竞争的轮询次数也减少了很多，这也大大节省了CPU缓存同步的消耗，从而大大提升系统性能。

[论文](http://www.cs.tau.ac.il/~shanir/nir-pubs-web/Papers/CLH.pdf)

